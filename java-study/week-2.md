## 2주차 스터디 : 자바 데이터 타입, 변수 그리고 배열
### 학습 목표(필수)
- 프리미티브 타입 종류와 값의 범위 그리고 기본값
- 프리미티브 타입과 레퍼런스 타입
- 리터럴
- 변수 선언 및 초기화하는 방법
- 변수의 스코프와 라이프타임
- 타입 변환, 캐스팅 그리고 타입 프로모션
- 1차 배열 및 2차 배열 선언하기
- 타입 추론, var
___
___
## 1. 변수(Variable)
프로그래밍에서의 변수는 어떠한 값을 저장할 수 있는 메모리상의 공간을 의미합니다. 좀 더 정확히 말하면 **변수란 단 하나의 값을 저장할 수 있는 메모리 공간**이라고 할 수 있습니다. 이 메모리 공간에 이름을 붙일 수 있는데, 이 이름을 **변수명**라고 합니다. 그렇다면 변수는 어떻게 만드는 것일까요?

### 1-1. 변수의 선언과 초기화
'변수를 만드는 것'을 프로그래밍에서는 '변수를 선언한다'라고 합니다. 변수를 선언하는 방법은 간단합니다.

<img width="260" alt="스크린샷 2021-09-04 오후 11 38 08" src="https://user-images.githubusercontent.com/80696862/132098209-0da97672-9f25-476e-8bc0-ac0b8e34583e.png">


위의 코드는 세 부분으로 나눌 수 있는데, **변수 타입** 부분, **변수 이름** 부분, 그리고 **값 할당** 부분으로 나눌 수 있습니다. 

변수의 타입이란 값의 형태를 뜻하고 변수의 이름은 말그대로 변수의 이름입니다. 이 변수의 이름으로 메모리에 공간이 생깁니다. 그리고 값 할당 부분은 이 메모리 공간에 어떠한 값을 실제로 저장할 것인지 써놓는 곳입니다. 

변수를 선언한다는 것은 변수의 타입과 변수 이름만 결정한 것이고, 변수를 초기화했다는 것은 변수를 선언한 후 여기에 실제 값을 할당했다는 뜻입니다. 이렇게 변수에 값이 할당되면, 이는 값이 메모리에 저장되었다는 뜻이고 나중에 이 값을 재사용할 수 있다는 뜻이 됩니다. 재사용시에는 이 변수의 이름을 기억하면 됩니다.

**변수 선언의 예**
```java
int number;
```

**변수 초기화의 예**
```java
number = 7;
```

**변수 선언과 초기화를 동시에**
```java
int number = 7;
```

그리고 변수(Variable)라는 이름에서 알 수 있듯이, 변수는 언제든 변할 수 있는 값입니다. 언제든 이 변수에 새로운 값을 할당할 수 있고, 이 때 기존의 값은 삭제됩니다. 이는 **상수**라는 것과 대비되는 특징입니다.

### 1-2. 상수(Constant)와 리터럴(Literal)
프로그래밍에서 **상수**는 변수와 마찬가지로 값을 메모리에 저장하는 공간이지만, 변수와는 다르게 한번 값이 할당(초기화)되면 이후 다른 값으로 변경할 수 없는 특징이 있습니다. 상수를 선언하는 방법은 변수와 동일하며, 변수의 타입 앞에 **final** 키워드만 붙여주면 됩니다. 그리고 관례적으로 상수명은 모두 대문자로 적습니다.

```java
final int MAX_SPEED = 200;
```

**리터럴**은 단순히 값 자체를 의미합니다. 실제 우리가 변수에 할당하는 값들이 리터럴 입니다.
```java
int weight = 70;
final int height = 170;
```
위 코드에서 weight는 변수이고 height는 상수입니다. 그리고 이 변수와 상수에 각각 할당된 값인 70과 170을 리터럴이라고 합니다.
___

## 2. 데이터 타입
위에서 변수의 **타입**이라는 것을 언급했습니다. 여기서 타입은 무엇이고 언제 사용하는 것일까요?

**타입이란 공통점을 기반으로 어떠한 값들을 묶어둔 개념적인 형태**입니다. 가령, 자바에는 숫자들을 저장할 수 있는 숫자 타입과, 참과 거짓의 논리를 저장할 수 있는 논리 타입, 그리고 문자를 저장할 수 있는 문자 타입이 있습니다. 다시 말해 타입이란 이 변수에 할당된 값이 어떠한 형태이고 어떻게 사용될 것인지 쉽게 추론할 수 있게 해주는 역할을 하는 인식표라고 할 수 있습니다.

만약 프로그래밍에서 타입이 없다면 어떤 일이 벌어질까요? 두 변수를 연산을 하는데 이 변수에 저장된 값이 숫자인지, 문자인지, 논리인지 알 수 없다면 어떨까요? 개발자는 일일히 이 변수에 어떠한 값들이 있는지 일일히 확인하고 연산을 할 수 있는 값들만 하나하나 추려내야 할 것입니다. 상당히 수고로운 작업이라고 할 수 있겠네요. 하지만 우리는 타입이라는 고마운 존재 덕분에 이런 고생 없이 쉽게 값의 형태를 유추해서 사용할 수 있습니다. (물론 타입의 장점은 이것보다 훨씬 많습니다.)

### 2-1. 데이터 타입의 종류
자바에서의 값은 크게 **기본형**과 **참조형**이라는 데이터 타입으로 분류됩니다. 기본형은 자바에서 기본적으로 제공하는 데이터 타입입니다. 기본형의 변수엔 실제 연산을 위한 값들이 저장됩니다. **참조형은 기본형이 아닌 모든 값들을 아우르는 타입**입니다. 기본형이 아닌 값들은 모두 참조형이라고 생각하시면 됩니다. 이 참조형은 객체의 주소를 저장하는데, 이는 뒤에 클래스를 배우는 시간에 좀 더 자세히 알아볼 것입니다. 기본형과는 다르게 참조형의 값은 계산할 수 없습니다.
___

## 3. 기본형(Primitve type)
기본형에는 모두 8개의 타입(byte, short, char, int, long, float, double, boolean)이 존재하며, 각 타입마다 할당받을 수 있는 값의 범위와 메모리 공간이  다릅니다.

<img width="600" alt="스크린샷 2021-08-31 오후 9 31 35" src="https://user-images.githubusercontent.com/80696862/131839305-e37f0ed6-aa40-4c58-a9ca-fad708cf8361.png">

<img width="500" alt="스크린샷 2021-08-31 오후 9 31 35" src="https://user-images.githubusercontent.com/80696862/131839718-bc9d301e-f228-41f0-ac42-d0711ff8b212.png">

### 3-1. 논리 타입(boolean)
논리형은 참 혹은 거짓처럼 둘 중 하나의 값을 표현할때 사용합니다. 남자 혹은 여자, 기혼 미혼 pass or fail 등 일종의 논리를 구현하는데 사용할 수 있습니다. 논리형의 기본값은 **false**입니다.

**논리형의 변수에 값을 저장**
```java
boolean isMale = true;
boolean isPassed = false;
```

자바에서는 관례상 논리형 변수명의 접두사로 **is**를 붙입니다. isMale, isPassed처럼 개발자는 변수명만 보고 이 값이 쉽게 논리형이라는 것을 유추할 수 있습니다.

논리형에서는 두 개의 값(참 혹은 거짓)만 사용할 수 있기 때문에 1byte(8bits)의 메모리 공간이 할당됩니다. 1byte는 컴퓨터에서 데이터를 저장하는 최소 단위입니다.

### 3-2 문자 타입(char)
문자 타입은 오직 **한 글자**의 값만 저장하고자 할 때 사용됩니다. 

```java
char gender = 'M';
```
위의 코드를 보면 gender 변수에 'M'이라는 값이 저장되는 것 처럼 보입니다. 하지만 문자형 변수엔 문자가 아닌 **유니코드**라는 정수를 저장합니다. 컴퓨터는 오직 숫자만 인식할 수 있기 때문에 모든 값을 유니코드로 메모리에 변환해서 저장합니다. 'M'의 유니코드는 77입니다. 이는 아래코드에서 확인할 수 있습니다.
```java
char gender = 'M';
int unicode = (int) gender;
System.out.println("unicode is : " + unicode);
```
gender 변수명 앞에 **(int)** 라는 것이 있는걸 볼 수 있는데, 이것은 해당 값의 입을 강제로 바꿔주는 작업을 하는 연산자입니다. 아래에서 좀 더 다뤄보겠습니다.

char 타입엔 2bytes의 메모리 공간이 할당됩니다.

### 3-3. 정수 타입(byte, short, int, long)
프로그래밍에서 가장 자주 사용되는 값인 정수에는 4 종류의 데이터 타입이 존재합니다. 그리고 각 타입이 저장할 수 있는 값의 범위와 메모리 공간 모두가 다릅니다.

```java
byte a;
short b;
int c;
long d;
```

각 정수 타입 별로 변수를 선언했습니다. 그러면 아래 그림처럼 메모리 공간이 형성됩니다.

<img width="500" alt="스크린샷 2021-09-03 오후 11 09 02" src="https://user-images.githubusercontent.com/80696862/132019032-1389a070-3478-47b5-a79a-0168d17a2a23.png">

그렇다면 각 변수에 실제 값을 할당하면 어떻게 될까요?
```java
byte a 10;
short b = 100;
int c = 1000;
long d = 20000L;
```

위의 메모리 저장공간에 각 변수에 할당된 값들은 이진수로 변환되어 저장됩니다. 또한 각 정수 타입들은 위 그림에서 할당된 공간이 다른것 처럼 담을 수 있는 값의 범위 또한 모두 다릅니다. 각 정수 타입의 값의 범위는 아래 표와 같습니다.

|타입|저장 가능한 값의 범위|bit|byte|
|:--:|:--:|:--:|:--:|
|byte|-128 ~ 127(-2^7^ ~ 2^7^-1)|8|1
|short|-32,768 ~ 32,767(-2^15^ ~ 2^15^-1)|16|2
|int|-2^31^ ~ 2^31^- 1|32|4
|long|-2^63^ ~ 2^63^ - 1|64|8

각 변수는 각자의 타입에 따라 할당받을 수 있는 값의 범위가 다르며, 그 이상을 할당받게될 경우 문법 오류가 발생하게 됩니다. 하나 예를 들어보겠습니다.

위의 표를 보면, long타입이 받을 수 있는 값의 최대 크기는 2^63^-1 입니다. 그리고 int타입이 받을 수 있는 최대 값의 크기는 2^31^-1(약 21억 정도)입니다. 만약 int 타입 변수에 22억의 값을 할당하면 어떻게 될까요? 

<img width="358" alt="스크린샷 2021-09-04 오후 11 25 46" src="https://user-images.githubusercontent.com/80696862/132097824-53291a76-2044-4645-a315-20be6c6c153f.png">

위 코드처럼 할당하는 숫자에 빨간줄이 그이는 에러가 생기게 됩니다. 개발자가 소스 파일(자바 파일)에 작성하는 코드는 소스 코드라고 하며, 이 소스 코드에 문법적인 오류가 있을 경우 컴파일러가 위 그림처럼 빨간줄로 문법 오류가 난 위치를 알려줍니다. 이런 오류를 **컴파일 에러**라고 부릅니다.

하나 더 신기한 것을 알아보겠습니다. int타입의 최대값은 약 21억 정도가 된다고 하였습니다. 그렇다면 int타입의 최대값보다 큰 22억을 int타입보다 더 큰 값을 저장할 수 있는 long타입에 저장하면 무슨일이 일어날까요?

<img width="218" alt="스크린샷 2021-09-04 오후 11 46 57" src="https://user-images.githubusercontent.com/80696862/132098494-3fc34917-17ac-4bdd-8231-8293c812f496.png">

이상하게도 컴파일 에러가 발생합니다. 분명히 long 타입은 22억이라는 값을 할당받을 수 있는데 무슨일일까요?

<img width="342" alt="스크린샷 2021-09-04 오후 11 51 08" src="https://user-images.githubusercontent.com/80696862/132098656-5a8bed97-d416-47b0-8b3d-ad03dc7f5613.png">

컴파일 에러 내용을 확인하고 싶으면 빨간줄에 마우스를 갖다대면 됩니다. 에러 내용은 "Integer numner too large". 아까 int에 담을때 발생한 에러 내용과 동일합니다. 그 이유는

<img width="221" alt="스크린샷 2021-09-05 오전 12 26 24" src="https://user-images.githubusercontent.com/80696862/132099723-13a057da-8cda-4e40-8337-76564c3228be.png">

이 컴파일 에러를 해결하는 방법은 숫자 뒤에 L을 명시하는 것입니다. 이를 통해 해당 변수에 저장할 값은 long타입이다 라고 컴파일러에게 알려줄 수 있습니다. 

#### 정수형 선택 기준
변수의 저장하려는 값에 따라 타입을 선택하면 되지만, 저장 공간이 상대적으로 작은 byte와 short 대신 저장공간이 넉넉한 int타입을 사용하는 것이 좋습니다. byte, short 타입은 저장공간을 절약할 수 있는 장점이 있지만, 반대로 그만큼 담을 수 있는 값의 범위가 작은 것 또한 단점입니다. 

정리하자면, 정수형 변수를 선언할 때는 int타입을 사용하고, int의 범위(약 20억) 이상의 수를 다뤄야 할 경우엔 long타입을 사용하면 됩니다.

### 3-4. 실수 타입(float, double)
자바에서 실수를 저장할 수 있는 타입은 float과 double 타입이 있습니다. 각 타입이 변수에 저장할 수 있는 값의 범위는 아래 표와 같습니다.

|타입|저장 가능한 값의 범위(양수)|정밀도|bit|byte|
|:--:|:--:|:--:|:--:|:--:|
|float|1.4 x 10-^-45^ ~ 3.4 x 10^38^|7자리|8|1
|double|4.9 x 10^-324^ ~ 1.8 x 10^308^|15자리|16|2

실수형인 float과 double은 다른 정수형과 마찬가지로 얼마나 큰 수를 표현할 수 있는지도 중요하지만, 얼마나 0과 가까운 수를 표현할 수 있는지도 중요합니다. 따라서 float 타입의 경우 -1.4 x 10^-45^ ~ 1.4 x 10^-45^의 범위에 해당하는 값은 표현할 수 없습니다. **(단, 0만 표현 가능)** 이것은 double형도 마찬가지입니다.

그런데 여기에서 신기한 것이 있습니다. int형과 float형은 똑같이 메모리 저장공간으로 4bytes를 할당받습니다. 하지만 int형이 표현할 수 있는 최대값보다 float형이 표현할 수 있는 최대값이 더 큽니다. 같은 저장공간을 할당받았는데 어떻게 float형이 더 큰 값을 할당받을 수 있을까요?


<img width="400" alt="스크린샷 2021-09-05 오후 4 54 25" src="https://user-images.githubusercontent.com/80696862/132119715-7806eea2-b219-4e8d-be8b-f56a573d3496.png">

위 그림은 int형과 float형이 값을 저장하는 방식을 표현한 것입니다. int형의 저장공간은 값의 부호를 표현하는 1byte부분과 숫자를 저장하는 나머지 31bit 부분으로 이루어져있지만, float형은 부호 부분 1bit, 지수(E) 부분 8bit, 가수(M) 부분 23bit로 이루어져있습니다. 이것이 어떠한 차이를 만들어낼까요? 그것을 알기 위해선 지수와 가수를 알아야 합니다.

#### 실수형의 값 저장방식
위에서 설명한 것처럼 실수형의 저장형태가 S, E, M 세 부분으로 이루어진 것을 부동소수점수(floating-point)라고 부릅니다. 부동소수점수는 실수를 '+-M x 2^E^' 형태로 표현합니다.
___

## 4. 레퍼런스 타입(Reference type)
레퍼런스 타입은 참조 타입이라고도 하며, 자바에서 기본형이 아닌 값은 모두 레퍼런스 타입입니다. 레퍼런스 타입은 기본형처럼 어떠한 값을 저장하는 것이 아닌 메모리의 주소를 저장하는 타입입니다. 한번 기본형과 함께 값이 어떻게 저장되는지 비교해보겠습니다.

```java
int number = 4;
String name = "nicky";
```

기본형 타입 number와 참조 타입 name을 초기화했습니다. 메모리 공간은 어떻게 되어있을까요?

<img width="500" alt="스크린샷 2021-09-05 오전 2 42 19" src="https://user-images.githubusercontent.com/80696862/132103662-159b888a-4706-460e-b5c5-8bc4efae5e76.png">


위 그림처럼 int타입 number에는 메모리 공간에 값 4가 바로 저장되지만, 참조 타입 name에는 값 nicky가 바로 저장되는 것이 아닌 값 nicky가 저장되어있는 메모리 공간의 주소를 저장하고 있는 것을 확인할 수 있습니다. 더 자세한 내용은 클래스를 배울 때 다뤄보겠습니다. 여기선 참조형 변수는 메모리에 실제 값을 저장하고 있는 것이 아닌 실제 값이 따로 저장되어있는 곳의 메모리 주소를 갖고 있다고만 생각하면 됩니다.
___

## 5. 형변환(Casting)
**형변환이란, 변수 또는 상수의 타입을 다른 타입으로 변환하는 것**을 말합니다. 영어로는 type casting이라고 합니다. 타입은 자동으로 변환되기도 하고 수동으로 개발자가 변환할 수도 있습니다. 형변환 방법은 아래와 같습니다.

> **(타입) 피연산자**

정말 간단합니다. 단지 형변환을 하고 싶은 변수나 리터럴 앞에 변환하고자 하는 타입을 소괄호 안에 명시하기만 하면 됩니다. 여기서 사용되는 소괄호를 '**형변환 연산자**'라고 부릅니다.

### 5-1. 자동 형변환
자동 형변환은 형변환 연산자를 사용하지 않고도 자동으로 형변환이 이루어지는 것을 말합니다. 작은 타입의 변수를 큰 타입으로 변경할 때 발생합니다. 먼저 코드로 살펴보겠습니다.

<img width="460" alt="스크린샷 2021-09-05 오후 6 57 34" src="https://user-images.githubusercontent.com/80696862/132122768-5b390a00-b066-4814-b347-94402fa8c8c4.png">

MyClass 내부에 int 타입 a 변수는 정수 200을 갖고 있고 long 타입의 b에는 a 할당했습니다. 우리가 배운 바로는 long 타입에 int 타입의 변수를 할당했으므로 타입 미스매치로 컴파일 에러가 발생해야 합니다. 하지만 자바의 컴파일러는 작은 타입의 변수를 큰 타입에 할당한 것이므로 컴파일시 (long)을 a 앞에 붙여줍니다. 진짜로 그럴까요?

**컴파일된 바이트코드를 디컴파일한 코드의 사진**
<img width="500" alt="스크린샷 2021-09-05 오후 6 56 16" src="https://user-images.githubusercontent.com/80696862/132122736-12a18b5b-234d-431a-9e5e-a3de0396e9a9.png">

네. 진짜로 붙여줍니다. int의 메모리 저장공간은 4byte고 long의 메모리 저장공간은 8byte입니다. 작은 공간에 들어있던 값을 더 큰 공간으로 옮기는 것이니 값이 유실되거나 변경될 우려가 전혀 없습니다. 따라서 컴파일러는 타입 연산자가 명시되어있지 않아도 알아서 컴파일시 타입 연산자를 만들어 붙여줍니다. 반대의 경우엔 어떨까요?

*(9번째에서 10번째 라인에도 새로운 코드가 생겼는데, 이것도 컴파일러가 만들어준 코드입니다. 이는 클래스를 배울때 더 알아보겠습니다.)*

<img width="470" alt="스크린샷 2021-09-05 오후 7 11 47" src="https://user-images.githubusercontent.com/80696862/132123117-02bf0584-893a-43be-9eab-f73b7fbd292d.png">

이번엔 long 타입인 c 변수에 정수값 20,000을 할당했습니다. 20,000은 int 범위에도 속하는 값입니다. 그리고 변수 c를 int 타입 d에 할당했는데 아까와는 다르게 컴파일 에러가 발생합니다. 하늘색 상자를 보면, 요구된 타입은 int인데 할당된 타입은 long이라고 적혀있습니다. 왜 큰 타입에서 작은 타입으로는 자동 형변환이 되지 않을까요?

이유는 큰 저장공간의 값을 작은 저장공간으로 옮길 경우 값이 유실되어 변형될 우려가 있기 때문입니다. long 타입은 메모리 저장공간이 8byte고 int는 4byte라고 했습니다. 물론 정수 20,000은 long과 int의 범위에 모두 속하는 값입니다. 하지만 long범위에만 속하는 약 22억 이상의 값이 c에 저장되어있다면 어떨까요?

'10000011001000010101011000000000'는 22억의 2진법 표기입니다. 자릿수를 세어보면 총 32자리입니다. int는 4byte로 총 32bit의 공간이 있습니다. 하지만 앞서 배웠듯 자바에서는 비트의 맨 앞자리는 Signal bit(부호 비트)로, 저장된 값이 양수인지 음수인지를 알려주는 비트입니다. 따라서 실제 값을 할당받을 수 있는 공간은 32-1인 31bit가 되게됩니다. 직접 22억과 21억의 2진법을 비교해보면...

**22억 : 10000011001000010101011000000000 (32자리)**
**21억 : _1111101001010110111010100000000 (31자리)**

이렇기 때문에, 22억은 값의 유실 없이는 int형에 담을 수 없기 때문에 컴파일러가 필요하면 형변환을 하라고 컴파일 에러로 개발자에게 알려주는 것입니다. 영문도 모르게 자동형 변환이 되어 값이 유실되면 프로그래밍 연산에서 치명적인 오류를 발생시킬 수 있기 때문이죠. 그렇다면 이젠 22억을 강제로 형변환을 한 후의 값을 확인해보겠습니다.

<img width="400" alt="스크린샷 2021-09-05 오후 10 20 01" src="https://user-images.githubusercontent.com/80696862/132128421-12f1b121-6e1f-49b8-9009-7b79e3262029.png">

d의 출력값은 위처럼 이상한 음수값이 나옵니다. 어떻게된 일일까요?? 아까 22억을 2진수로 변환하면 총 32자리고 21억을 변환하면 31자리라고 했습니다. 여기서 22억이 할당된 c를 int로 형변환한다면 

그러면 

<img width="470" alt="스크린샷 2021-09-05 오후 7 45 11" src="https://user-images.githubusercontent.com/80696862/132123990-046fb4c3-2119-4536-af28-e848fac0f75e.png">

이번엔 컴파일 에러가 발생하지 않습니다. 바로 d의 값도 확인해보겠습니다. 변수의 값을 확인하고 싶을땐, 아래의 출력문을 사용하시면 됩니다.
```java
System.out.println(d);
```

<img width="400" alt="스크린샷 2021-09-05 오후 10 17 00" src="https://user-images.githubusercontent.com/80696862/132128347-83a23fe1-d210-42f7-9483-701a6356547b.png">

d의 값이 c와 동일한 20,000이 잘 출력되는 것을 확인할 수 있습니다. 이렇게 큰 타입의 변수를 작은 타입으로 변환하더라도 큰 타입의 변수의 값이 작은 타입의 범위에 해당된다면, 값의 유실 없이 정상적으로 형변환이 이루어집니다. 하지만 22억처럼 int형의 범위를 넘어서는 값을 int형으로 형변환을 할 경우 값에 유실이 발생합니다.
___

## 6. 배열 타입(Array)
우리가 기본 타입을 배우면서 초기화했던 변수들은 메모리 공간에서 모두 흩어져 있습니다. 변수들이 흩어져 있다면 찾기도 어려울 테고 필요할때마다 매번 새로운 변수를 선언해야 하는 등, 사용하기에도 번거로울 것입니다. 그래서 자바를 포함한 프로그래밍 언어에서는 배열이라는 타입을 제공합니다. 

배열은 같은 타입의 여러 변수를 **한 묶음**으로 다룹니다. 그리고 배열 내부에 저장되어 있는 값엔 변수명이 아닌 인덱스 번호로 접근할 수 있습니다. 먼저 배열을 생성하고 사용하는 방법을 알아보겠습니다.

```java
int[] scores = new int[5];
```

기본적인 배열 생성 방법은 위 코드와 같습니다. int[ ]는 변수 scores의 타입이 int형 배열라는 것을 의미합니다. 그리고 **new** 키워드는 자바의 연산자 중 하나로 참조형 변수를 초기화할 때 사용되며, 이 때 메모리에 공간이 생깁니다. 이 곳엔 scores 배열의 주소값이 저장되어 있습니다. 그리고 int[5]는 이 int형 배열의 크기가 5라는 것을 의미합니다. 즉, 총 5개의 값을 저장할 수 있다는 뜻입니다.

배열을 선언하는 방법은 더 있습니다.
```java
int scores[] = new int[5];
```
이렇게 타입이 아니라 변수명에 [ ]를 붙이는 방법도 있습니다. 이러면 변수명을 보고 배열이라는 것을 확인할 수 있다는 장점이 있습니다. 하지만 저는 다른 타입들의 변수와 일관성을 위해 int[ ] 방식을 선호합니다. 이제 배열 생성시 메모리 구조를 한번 살펴보겠습니다.

<img width="500" alt="스크린샷 2021-09-06 오후 9 51 50" src="https://user-images.githubusercontent.com/80696862/132220425-4ab4c32d-7414-4411-8b06-c2afa158ae6c.png">

배열을 생성한 순간 변수명 scores라는 이름으로 메모리 공간이 생깁니다. 그리고 우리는 이 변수를 통해서 인덱스 0번부터 4번까지의 공간에 접근할 수 있습니다. 배열의 각 공간을 배열의 요소(element)라고 부릅니다. 아직 우리가 배열을 생성만 했지 실제 배열의 각 요소에 값을 할당하지 않았기 때문에 각 요소엔 int타입의 초기값인 0이  저장되어있습니다. 이번엔 배열에 값을 할당하는 방법을 알아보겠습니다.

> **어떤 프로그래밍 언어에서건 인덱스 번호는 무조건 0부터 시작합니다. 즉, 인덱스의 범위는 0부터 배열길이-1 까지입니다.**

```java
scores[0] = 80; //0번방에 값 할당
scores[1] = 100; //1번방에 값 할당
scores[2] = 60; //2번방에 값 할당
scores[3] = 80; //3번방에 값 할당
scores[4] = 90; //4번방에 값 할당
```

<img width="500" alt="스크린샷 2021-09-06 오후 10 03 17" src="https://user-images.githubusercontent.com/80696862/132221732-31158f52-8ea0-4dbe-830d-0d38c68c669d.png">

요소에 값을 할당하는 방법은 **변수명[인덱스번호] = 리터럴;** 입니다. 이렇게 배열을 선언하면 더이상 새로운 변수를 생성할 필요가 없이 배열의 변수명과 인덱스만으로 많은 값들을 관리할 수 있습니다.

___

## 6. 변수의 스코프와 라이프타임
자바에서는 변수가 선언되는 위치에 따라 변수의 종류가 달라집니다. 총 세 종류로, 클래스 변수, 인스턴스 변수, 지역 변수가 있으며, 모두 생성 주기가 다릅니다.

|변수의 종류|선언 위치| 생성 시기|
|:--:|:--:|:--:|
|클래스 변수|클래스 영역|클래스가 메모리에 로딩될 때|
|인스턴스 변수|클래스 영역|인스턴스가 생성되었을 때|
|지역 변수| 클래스 영역 이외의 모든 영역|변수 선언문이 수행되었을 때|

<img width="500" alt="스크린샷 2021-09-06 오후 10 34 25" src="https://user-images.githubusercontent.com/80696862/132225351-3b6575ad-fd16-42d6-9d35-f2a34b152e9b.png">

클래스 블럭(중괄호)가 시작된 5번째 라인부터 블럭이 끝나는 16번째 라인 내부에 선언된 변수들은 모두 **멤버 변수**라고 하며, static 키워드가 없는 변수를 인스턴스 변수, 있는 변수를 클래스 변수라고 부릅니다. 하지만 10번째 줄에서 14번째 줄까지의 메소드 블럭 내부(파란색 영역)에 선언된 모두 변수는 멤버변수가 아닌 지역 변수라고 부릅니다. 각 변수들을 좀 더 자세히 알아보겠습니다.

### 6-1. 인스턴스 변수(Instance variable)
인스턴스 변수는 클래스 영역에 선언하며, 클래스의 인스턴스를 생성할 때 만들어집니다. 인스턴스는 독립적인 메모리 저장공간을 가지므로 인스턴스끼리 변수를 공유할 수 없습니다. 따라서 인스턴스마다 고유한 값을 저장해야하는 경우에는 인스턴스 변수를 만들어서 사용합니다. 인스턴스 변수는 더이상 인스턴스가 사용되지 않을 때 GC가 인스턴스를 제거하는데, 이 때 같이 소멸됩니다.

 *(지금은 클래스는 한가지 품목만 생산하는 공장, 인스턴스는 그 공장의 양산품 정도로만 생각하면 됩니다. 어떤 품목을 만들어내는 공장에서 생산라인마다 조금씩 다른 물건을 만들듯이, 인스턴스도 해당 클래스로부터 여러개의 모습으로 만들어질 수 있습니다.)*

 ### 6-2. 클래스 변수(Class variable)
 클래스 변수는 인스턴스 변수 앞에 static 키워드가 붙은 변수입니다. 인스턴스가 독립적인 저장 공간을 갖는 것과는 달리, 클래스 변수는 모든 인스턴스가 공유할 수 있는 저장공간입니다. 클래스가 로딩될 때 클래스 수준의 정보로 JVM의 메모리 영역에 저장됩니다. 모든 인스턴스가 공통적으로 필요한 값의 경우엔 클래스 변수로 선언합니다. 그리고 클래스 변수는 자바 프로그램이 종료될 때 소멸됩니다.

 ### 6-3. 지역 변수(Local variable)
 지역변수는 메소드 블럭 내에 선언된 변수입니다. 위 그림에서는 파란색 영역 내부에 선언된 변수 lv입니다. 그리고 나중에 배울 for문과 if문 블럭 내부의 변수도 지역 변수입니다. 지역 변수는 메소드가 종료되면 소멸됩니다.

___

## 7. 타입 추론, var

___

참고 : [객체지향의 사실과 오해](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=60550259), [처음 해보는 자바 프로그래밍](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=179702789), [자바의 정석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=76083001), [maru's 원자적 사고](https://catch-me-java.tistory.com/14?category=438116)

