## 6주차 스터디
### 목표
자바의 상속에 대해서 학습하세요.
### 학습할 것 (필수)
- 자바 상속의 특징
- super 키워드
- 메소드 오버라이딩
- 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
- 추상 클래스
- final 키워드
- Object 클래스

___

## 1. 자바의 상속이란? (Inheritance)
상속이란 부모 클래스의 멤버들(필드, 메소드, 중첩 클래스)을 자식 클래스에서 그대로 물려받는 것을 의미합니다. 부모(parent) 클래스를 상위(super) 클래스, 기반(base) 클래스라고 하며, 자식(child) 클래스를 하위(sub) 클래스, 또는 파생된(derived) 클래스라고 합니다.

자바에서 상속을 사용하는 방법은 자식 클래스 명 뒤에 **extends** '부모 클래스 명'을 붙여주면 됩니다.

```java
public class Child extends Parent {
    //필드
    //생성자
    //메소드
}
```

extends 키워드를 사용함으로써 Child 클래스는 부모 클래스인 Parent 클래스의 모든 것을 상속받습니다. 하지만 상속시 상속되지 않는 것들도 있습니다.

- 부모 클래스의 생성자
- 부모 클래스의 초기화 블럭
- 부모 클래스에서 private 키워드가 붙은 필드와 메소드

## 2. 상속의 특징
- **코드의 재사용성을 높인다**
    공통적으로 가져야 할 부분들은 모두 부모 클래스에 작성해 코드를 재사용할 수 있습니다.
- **코드의 중복을 제거해 프로그램의 생산성과 유지보수에 도움을 준다**
    부모 클래스ㅇ
- **다중 상속이 불가능하다**
    자바는 오직 단일 상속만 지원합니다.

## 오버라이딩(Overriding)
오버라이딩이란 상속 관계에서 부모 클래스의 메소드를 자식 클래서에서 재정의하는 것입니다. override의 사전적 정의는 '~위에 덮어쓰다(overwrite)'로, 자식 클래스가 부모 클래스의 메소드를 자신에게 맞게 변경할 때 사용합니다.

### 오버라이딩 조건
- 메소드 시그니처가 같아야 한다
- 메소드 반환타입이 같아야 한다
- JDK 1.5부터는 반환타입을 자식 클래스의 타입으로도 변경할 수 있다 (공변 반환타입)

오버라이딩시에는 위 세개의 조건이 꼭 지켜져야 합니다. 하지만 메소드의 접근 제어자와 예외 부분은 제한된 조건 내에서 변경할 수 있습니다.

 **1. 접근 제어자는 부모 클래스의 메소드보다 더 좁은 타입으로 변경할 수 없다.**

 **2. 부모 클래스의 메소드보다 더 많은 수의 예외를 선언할 수 없다.**

 ### @Override 애노테이션
 애노테이션이란 

 ### 헷갈리는 오버라이딩과 오버로딩
 오버라이딩과 오버로딩은 어감상 많이 헷갈립니다. 하지만 이들이 의미하는 바는 전혀 비슷하지 않습니다. 오버로딩은 **추가**의 개념입니다. 메소드 이름만 같고 시그니처가 다른 메소드들이 추가되는 것이 오버로딩이고, 상속받은 내용을 **변경**하는 것이 오버라이딩입니다.

## 3. super 키워드
super 키워드는 자식 클래스에서 부모 클래스로부터 상속받은 멤버를 참조하는데 사용되는 변수입니다. 동일 클래스에서 멤버변수와 지역변수의 이름이 같을 때 this 키워드를 통해 이를 구별했듯이, super 키워드는 자식 클래스의 멤버와 부모 클래스의 멤버의 이름이 같을 때 super를 통해 구별합니다.

```java
public class Phone {

}
```

## 추상 클래스
추상 클래스란 **실체 클래스들이 공통적으로 가져야 할 필드와 메소드들을 정의해 놓은 클래스**입니다.

여기서 추상이란 어떤 존재들 간에 공통되는 특징들을 추출하는 것을 말합니다. 가령, 길거리에 많은 사람들이 있지만 **공통적으로** 같은 교복을 입은 사람들을 우리가 '학생'이라고 생각하는 것 처럼, 객체들 사이에서도 공통되는 특성들을 뽑아내서 하나의 상위 타입으로 만드는 작업을 **추상화**라고 합니다. 상속에서의 **구체화**(확장, extends)와는 대비되는 개념입니다. 추상화는 **무엇을(What)**에 관심을 두며 구체화는 어떻게**(How)**에 관심을 둡니다.

### 추상 클래스의 특징
- 최소 1개의 추상 메소드를 가져야한다. (추상 메소드가 1개라도 있으면 추상 클래스이다)
- 추상 클래스는 인스턴스화가 불가능하다.
- 추상 클래스를 상속했으면, 추상 클래스의 모든 추상 메소드를 오버라이딩해야 한다. 그렇지 않다면 해당 클래스도 추상 클래스로 선언해야 한다

### 추상 메소드란?
추상 메소드란 메소드의 선언부만 존재하고 실제 구현부는 없는 메소드입니다. 즉, 해당 메소드로 무엇을 할 것인지만 정의해놓고 실제 어떻게 동작하는지는 작성되지 않는 메소드입니다. 

```java
abstract void run();
```

### 왜 추상 메소드를 사용할까?
이전에 예시로 들었던 맥도날드 매장을 다시 예시로 들어보겠습니다. 매장에는 주문을 하는 손님, 카운터를 맡는 캐셔, 감자튀김을 만드는 직원, 햄버거를 만드는 직원, 배달을 하는 라이더 등 여러 역할이 있습니다. 

### 추상 클래스는 언제 사용될까?


## final 키워드

## Object 클래스
Object 클래스는 상속 계층의 최상위에 존재하는 조상 클래스입니다. 따로 다른 클래스를 상속하지 않는 클래스들은 컴파일시 컴파일러가 자동으로 **extends Object**를 붙여줍니다. 결국엔 자바의 모든 클래스는 Object 클래스로 형 변환할 수 있습니다. Object 클래스에는 인스턴스가 기본적으로 가져야 할 메소드들이 정의되어 있습니다.

|메소드 명|설명|
|:--:|--|
|boolean equals(Object obj)|두 개의 객체가 같은지 비교하여 같으면 true, 같지 않으면 false 반환
|String toString()|객체의 정보를 문자열로 반환|
|Object clone()|객체를 복사해서 반환|
|void finalize()||
|Class getClass|해당 객체의 Class 타입을 반환|
|int hashCode()|객체의 해쉬코드 값을 반환|
|void notify()|wait된 스레드 실행을 재개할 때 호출함|
|void norifyAll()|wait된 모든 스레드의 실행을 재개할 때 호출함|
|void wait()|스레드를 일시적으로 중지시킬 때 호출함|
|void wait(long timeout)|timeout만큼 스레드를 한시적으로 중지할 때 사용|

위 표에 정리된 메소드들은 자주 사용되는 Object 클래스의 메소드들입니다.

## 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)