## 6주차 스터디
### 목표
자바의 상속에 대해서 학습하세요.
### 학습할 것 (필수)
- 자바 상속의 특징
- super 키워드
- 메소드 오버라이딩
- 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
- 추상 클래스
- final 키워드
- Object 클래스

___

## 1. 자바의 상속이란? (Inheritance)
상속이란 부모 클래스의 멤버들(필드, 메소드, 중첩 클래스)을 자식 클래스에서 그대로 물려받는 것을 의미합니다. 부모(parent) 클래스를 상위(super) 클래스, 기반(base) 클래스라고 하며, 자식(child) 클래스를 하위(sub) 클래스, 또는 파생된(derived) 클래스라고 합니다.

자바에서 상속을 사용하는 방법은 자식 클래스 명 뒤에 **extends** '부모 클래스 명'을 붙여주면 됩니다.

```java
public class Child extends Parent {
    //필드
    //생성자
    //메소드
}
```

extends 키워드를 사용함으로써 Child 클래스는 부모 클래스인 Parent 클래스의 모든 것을 상속받습니다. 하지만 상속시 상속되지 않는 것들도 있습니다.

- 부모 클래스의 생성자
- 부모 클래스의 초기화 블럭

자식 클래스가 부모 클래스를 상속하면 자식 클래스는 부모 클래스로부터 상속받은 멤버들과 자식 클래스에 추가적으로 선언되어 있는 멤버드를 갖게 됩니다. 즉, 자식이 부모보다 많은 내용을 가질 수 있습니다. 그래서 상속시에 사용하는 키워드가 바로 **extends**(확장하다)입니다. 

## 2. 상속의 특징
- **코드의 재사용성을 높인다**
    공통적으로 가져야 할 부분들은 모두 부모 클래스에 작성해 코드를 재사용할 수 있습니다.
- **코드의 중복을 제거해 프로그램의 생산성과 유지보수에 도움을 준다**
- **다중 상속이 불가능하다**
    자바는 오직 단일 상속만 지원합니다.(단일 상속 원칙)
    여러 클래스가 한 클래스를 상속하는 것은 가능합니다
- **부모 클래스의 내용이 변경되면, 자식 클래스에도 전파됩니다. (강한 결합)**

## 오버라이딩(Overriding)
오버라이딩이란 상속 관계에서 부모 클래스의 메소드를 자식 클래서에서 재정의하는 것입니다. override의 사전적 정의는 '~위에 덮어쓰다(overwrite)'로, 자식 클래스가 부모 클래스의 메소드를 자신에게 맞게 변경할 때 사용합니다.

### 오버라이딩 조건
- 메소드 시그니처가 같아야 한다
- 메소드 반환타입이 같아야 한다
- JDK 1.5부터는 반환타입을 자식 클래스의 타입으로도 변경할 수 있다 (공변 반환타입)

오버라이딩시에는 위 3개의 조건은 꼭 지켜져야 합니다. 하지만 메소드의 접근 제어자와 예외 부분은 제한된 조건 내에서 변경할 수 있습니다.

 **1. 접근 제어자는 부모 클래스의 메소드보다 더 좁은 타입으로 변경할 수 없다.**

 **2. 부모 클래스의 메소드보다 더 많은 수의 예외를 선언할 수 없다.**

 **3. 인스턴스 메소드를 static 메소드로 변경하거나 혹은 그 반대로 변경할 수 없다.**

 ### @Override 애노테이션
 **애노테이션이란 컴파일러에게 추가적인 정보를 제공하는 주석**입니다. 애노테이션은 다음 3가지 용도로 사용됩니다.

 - 컴파일러에게 코드 문법 에러를 체크하도록 정보 제공
 - 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성하도록 정보 제공
 - 런타임 시 특정 기능을 실행하도록 정보 제공

 오버라이딩시 사용하는 @Override 애노테이션은 해당 애노테이션이 붙어있는 메소드가 오버라이딩한 메소드라고 컴파일러에게 알려줍니다. 그러면 컴파일 시 컴파일러가 해당 메소드의 선언부와 부모 클래스의 메소드의 선언부를 비교해서 오버라이딩한 메소드가 맞는지 체크하고, 오버라이딩 조건에 위배되면 컴파일 에러를 발생시킵니다.

 ### 헷갈리는 오버라이딩과 오버로딩
 오버라이딩과 오버로딩은 어감상 많이 헷갈립니다. 하지만 이들이 의미하는 바는 전혀 비슷하지 않습니다. 오버로딩은 **추가**의 개념입니다. 메소드 이름만 같고 시그니처가 다른 메소드들이 추가되는 것이 오버로딩이고, 상속받은 내용을 **변경**하는 것이 오버라이딩입니다.

## 3. super 키워드
super 키워드는 자식 클래스에서 부모 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수입니다. 동일 클래스에서 멤버변수와 지역변수의 이름이 같을 때 this 키워드를 통해 이를 구별했듯이, super 키워드는 자식 클래스의 멤버와 부모 클래스의 멤버의 이름이 같을 때 super를 통해 구별합니다.

또한 super()는 부모 클래스의 생성자입니다. 현실세계에서 부모가 있어야 자식이 있는 것 처럼, 자바에서도 부모 클래스가 먼저 생성됩니다. 따라서 자식 클래스 생성시, 자식 클래스 생성자의 맨 첫 줄에 호출합니다.

```java
public class Animal {

    protected int weight;
    protected char gender;
    protected String name;

    public Animal(int weight, char gender, String name) {
        this.weight = weight;
        this.gender = gender;
        this.name = name;
    }

    public void eat() {
        System.out.println("먹이를 먹습니다");
    }

}

public class Cat extends Animal {

    private String species;

    public Cat(int weight, char gender, String name, String species) {
        super(weight, gender, name); // 부모 생성자 호출
        this.species = species;
    }

    public void yaong() {
        System.out.println("야옹 소리를 냅니다.");
    }

    @Override
    public void eat() {
        System.out.println("고양이가 먹이를 먹습니다.");
    }

}
```

위 코드에서는 Cat 클래스에서 eat메소드가 오버라이딩되었습니다. 따라서 Cat 인스턴스에서 eat()을 호출 시 오버라이딩된 메소드가 호출됩니다. 그러나 부모 클래스의 eat 메소드를 호출하고 싶다면 super.eat()으로 접근하면 됩니다.

## 추상 클래스
추상 클래스란 **실체 클래스들이 공통적으로 가져야 할 필드와 메소드들을 정의해 놓은 클래스**입니다.

여기서 추상이란 어떤 존재들 간에 공통되는 특징들을 추출하는 것을 말합니다. 가령, 길거리에 많은 사람들이 있지만 **공통적으로** 같은 교복을 입은 사람들을 우리가 '학생'이라고 생각하는 것 처럼, 객체들 사이에서도 공통되는 특성들을 뽑아내서 하나의 상위 타입으로 만드는 작업을 **추상화**라고 합니다. 상속에서의 **구체화**(확장, extends)와는 대비되는 개념입니다. 추상화는 **무엇을**(What)에 관심을 두며 구체화는 **어떻게**(How)에 관심을 둡니다.

### 추상 클래스의 특징
- 최소 1개의 추상 메소드를 가져야한다. (추상 메소드가 1개라도 있으면 추상 클래스이다)
- 추상 클래스는 인스턴스화가 불가능하다.
- 추상 클래스를 상속했으면, 추상 클래스의 모든 추상 메소드를 오버라이딩해야 한다. 그렇지 않다면 해당 클래스도 추상 클래스로 선언해야 한다

### 추상 메소드란?
추상 메소드란 메소드의 선언부만 존재하고 실제 구현부는 없는 메소드입니다. 즉, 해당 메소드로 무엇을 할 것인지만 정의해놓고 실제 어떻게 동작하는지는 작성되지 않는 메소드입니다. 추상 메소드는 메소드 선언부 제일 앞에 **'abstract'** 키워드만 붙여주면 됩니다.

```java
abstract void run();
```

추상 메소드를 1개라도 갖는 클래스는 반드시 추상 클래스가 되어야 하며, 추상 클래스를 상속하는 클래스는 반드시 추상 메소드를 오버라이딩 해야합니다.

### 추상 클래스는 언제 사용될까?
이전에 예시로 들었던 맥도날드 매장을 다시 예시로 들어보겠습니다. 매장에는 주문을 하는 손님, 카운터를 맡는 캐셔, 감자튀김을 만드는 직원, 햄버거를 만드는 직원, 배달을 하는 라이더 등 여러 역할이 있습니다. 각 역할을 맡는 사람들은 상대방과 협력시 상대방이 일을 어떻게 하는지가 아닌 무엇을 해주는지가 중요합니다. 즉, 메소드를 호출하는 입장에서는 다음 두 가지만 알면 됩니다.
- 해당 메소드의 인자값으로 어떤 것이 필요한지
- 해당 메소드의 반환 타입은 무엇인지

고양이, 개 등은 우리가 '동물'이라고 추상화할 수 있습니다. 

<img width="300" alt="스크린샷 2021-09-22 오후 2 06 15" src="https://user-images.githubusercontent.com/80696862/134286453-497a4d94-0e48-4355-b4ab-333d2dd2dab4.png">

모든 동물들은 먹고, 자고, 걷고, 뛰는 등의 **공통적인 행동**을 합니다. 하지만, 각 동물들 고양이와 개 등은 각각 먹고 자고 걷고 뛰는 방식이 다릅니다. 즉, 고양이와 개에서 공통점을 추출해 동물이라는 추상적인 클래스를 만들고 이들의 공통점인 먹고, 자고, 걷고, 뛰는 등의 행동을 추상 메소드로 선언해서 실제 행위는 동물 클래스를 상속하는 클래스에서 구현(오버라이딩)하도록 강제하는 것입니다. 이렇게 같은 행위를 구현체마다 다르게 구현할 수 있는 특징을 **다형성**이라고 합니다.

## 다형성(Polymorphism)
다형성이란 하나의 객체가 여러 가지의 타입을 가질 수 있다는 특징을 말합니다. 즉, 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해줍니다. 

동물 추상 클래스를 구현한 클래스로 고양이와 개가 있습니다. 다형성을 위해 자식 클래스를 부모 클래스 타입으로 변환할 수 있습니다. **부모 타입엔 모든 자식 클래스 인스턴스를 대입할 수 있습니다.** 이것은 코딩을 하는데 있어 많은 유연함을 줍니다. 

```java
public class Zoo {

    public void feed(Animal animal) {
        System.out.println(animal.getName() + "에게 먹이를 줍니다.");
        animal.eat();
    }
}
```

동물원에서 동물들에게 먹이를 준다고 생각해봅시다. Zoo 클래스에 먹이를 주는 feed 메소드의 파라미터로는 Animal 타입을 받습니다. 즉, Animal 클래스를 상속한 자식 클래스인 Cat과 Dog의 인스턴스를 feed 메소드에 사용할 수 있다는 뜻입니다. feed 메소드 입장에서는 동물원의 모든 동물들에게 먹이를 주는 것이므로 그 동물이 고양이냐 개냐는 중요하지 않습니다. 단지 그것이 동물이기만 하면 상관없습니다.

### 참조변수의 형 변환
기본형에서도 그랬듯 참조변수도 형 변환이 가능합니다. 다만 참조변수 간 형 변환은 상속 관계나 인터페이스 구현 관계에서만 가능합니다. 그리고 모든 클래스는 Object 클래스를 상속하므로 Object 클래스로 형 변환할 수 있습니다.

- 업 캐스팅 (자식 타입 --> 부모 타입) : 형 변환 생략 가능(promotion)
- 다운 캐스팅 (부모 타입 --> 자식 타입) : 형 변환 생략 불가

```java
public abstract class Animal {

    protected String name;
    protected int age;

    public void eat();
}

public class Cat extends Animal {

    @Override
    public void eat() {
        System.out.println(this.name + "이 먹이를 먹습니다.");
    }
}
```

## final 키워드
final 키워드는 클래스, 필드, 메소드 선언시에 사용할 수 있으며, 말 그래도 '**최종적인**'이라는 뜻을 갖고 있습니다. final 키워드가 붙은 멤버는 **불변**(Immutable)의 상태가 됩니다.

#### final 변수
final 변수는 상수로 한 번 초기화되면 그 값을 변경할 수 없습니다. 자바 초기엔 이 final 상수를 선언과 동시에 초기화까지 했어야 했지만, 현재의 자바는 유연성을 더해서 선언만 해놓고 이후 딱 1번 초기화할 수 있습니다.

```java
final int MAX_NUMBER;
MAX_NUMBER = 1000;
MAX_NUMBER = 2000; //컴파일 에러
```

#### final 메소드
final 메소드는 오버라이딩이 불가능한 메소드입니다. 상속을 받는 모든 서브 클래스들이 부모의 것만 사용하게 하도록 강제합니다.

#### final 클래스
final 클래스는 상속할 수 없는 불변 클래스입니다. 불변 클래스를 상속 시 컴파일 에러가 발생합니다.

대표적인 불변 클래스로는 String 클래스가 있습니다. String 클래스를 포함한 불변 클래스의 이점은 아래와 같습니다.

1. 불변 객체
    - 1개의 인스턴스로 중복 항목을 공유할 수 있습니다
2. 보안
    - 변경될 염려 없는 read-only 데이터를 전달할 수 있습니다
3. 성능
    - 불변 데이터는 thread-safe합니다



### final 키워드를 왜 사용할까?
final 키워드를 사용하는 가장 큰 이유는 개발 의도와 코드의 가독성 때문입니다. final 키워드로 이 멤버는 불변이다라고 명시적으로(explicit) 표현함으로써 개발 의도를 확실하고 실수도 줄일 수 있습니다. final 키워드가 붙은 멤버를 변경시 컴파일 에러가 발생하기 때문입니다.

## Object 클래스
Object 클래스는 상속 계층의 최상위에 존재하는 조상 클래스입니다. 따로 다른 클래스를 상속하지 않는 클래스들은 컴파일시 컴파일러가 자동으로 **extends Object**를 붙여줍니다. 결국엔 자바의 모든 클래스는 Object 클래스로 형 변환할 수 있습니다. Object 클래스에는 인스턴스가 기본적으로 가져야 할 메소드들이 정의되어 있습니다.

|메소드 명|설명|
|:--:|--|
|boolean equals(Object obj)|두 개의 객체가 같은지 비교하여 같으면 true, 같지 않으면 false 반환
|String toString()|객체의 정보를 문자열로 반환|
|Object clone()|객체를 복사해서 반환|
|void finalize()||
|Class getClass|해당 객체의 Class 타입을 반환|
|int hashCode()|객체의 해쉬코드 값을 반환|
|void notify()|wait된 스레드 실행을 재개할 때 호출함|
|void norifyAll()|wait된 모든 스레드의 실행을 재개할 때 호출함|
|void wait()|스레드를 일시적으로 중지시킬 때 호출함|
|void wait(long timeout)|timeout만큼 스레드를 한시적으로 중지할 때 사용|

위 표에 정리된 메소드들은 자주 사용되는 Object 클래스의 메소드들입니다.

## 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)